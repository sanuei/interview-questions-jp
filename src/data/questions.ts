import { Question } from '@/types'

export const questions: Question[] = [
  // 自我介绍类问题
  {
    id: 'self-intro-1',
    category: 'general',
    subcategory: 'self-intro',
    question: {
      zh: '请简单介绍一下你自己',
      ja: 'まず、簡単に自己紹介をお願いします'
    },
    answer: {
      zh: '您好，我是[姓名]，拥有[年数]年的IT行业经验。我专注于[技术领域]，擅长[具体技能]。在之前的工作中，我负责[主要职责]，成功完成了[具体成就]。我对[相关技术]很感兴趣，希望在贵公司能够发挥我的专业技能，同时学习新的技术和业务知识。',
      ja: 'こんにちは、[名前]と申します。IT業界で[年数]年の経験があります。[技術分野]に専念し、[具体的なスキル]を得意としております。前職では[主な責任]を担当し、[具体的な成果]を成功させました。[関連技術]に興味があり、御社で私の専門技能を活かしつつ、新しい技術とビジネス知識を学びたいと思っております。'
    },
    tags: ['自我介绍', '基础问题'],
    difficulty: 'easy'
  },
  {
    id: 'self-intro-2',
    category: 'general',
    subcategory: 'self-intro',
    question: {
      zh: '为什么选择IT行业？',
      ja: 'なぜIT業界を選んだのですか？'
    },
    answer: {
      zh: '我选择IT行业主要有几个原因：首先，我对技术和创新有浓厚的兴趣，喜欢解决复杂的问题；其次，IT行业发展迅速，能够不断学习新技术，保持自己的竞争力；最后，通过技术可以创造价值，改善人们的生活，这让我感到很有成就感。',
      ja: 'IT業界を選んだ理由はいくつかあります。まず、技術と革新に深い興味があり、複雑な問題を解決することが好きです。次に、IT業界は急速に発展しており、常に新しい技術を学び、競争力を維持できます。最後に、技術を通じて価値を創造し、人々の生活を改善できることに大きなやりがいを感じています。'
    },
    tags: ['动机', '职业选择'],
    difficulty: 'easy'
  },

  // 优缺点分析
  {
    id: 'strengths-1',
    category: 'general',
    subcategory: 'strengths-weaknesses',
    question: {
      zh: '你的优点是什么？',
      ja: 'あなたの長所は何ですか？'
    },
    answer: {
      zh: '我的主要优点包括：1. 学习能力强 - 能够快速掌握新技术和新工具；2. 问题解决能力 - 喜欢分析问题的根本原因，寻找最佳解决方案；3. 团队合作 - 善于与不同背景的同事协作，共同完成项目目标；4. 责任心强 - 对工作认真负责，确保项目质量和进度。',
      ja: '私の主な長所は以下の通りです：1. 学習能力が高い - 新しい技術やツールを迅速に習得できます；2. 問題解決能力 - 問題の根本原因を分析し、最適な解決策を見つけることが得意です；3. チームワーク - 異なる背景を持つ同僚と協力し、プロジェクト目標を共に達成できます；4. 責任感が強い - 仕事に真摯に取り組み、プロジェクトの品質とスケジュールを確保します。'
    },
    tags: ['优点', '自我评价'],
    difficulty: 'easy'
  },
  {
    id: 'weaknesses-1',
    category: 'general',
    subcategory: 'strengths-weaknesses',
    question: {
      zh: '你的缺点是什么？如何改进？',
      ja: 'あなたの短所は何ですか？どのように改善していますか？'
    },
    answer: {
      zh: '我的缺点是有时候过于关注技术细节，可能会在某个技术问题上花费过多时间。为了改进这个问题，我现在会：1. 设定时间限制，避免过度深入某个技术细节；2. 定期与团队成员讨论，获得不同的视角；3. 平衡技术深度和项目进度的关系；4. 学习项目管理技能，更好地规划时间。',
      ja: '私の短所は、技術的な詳細に過度に集中しすぎることがあり、特定の技術問題に時間をかけすぎることがあります。この問題を改善するために、現在は以下を実践しています：1. 時間制限を設定し、技術的詳細への過度な深入りを避ける；2. チームメンバーと定期的に議論し、異なる視点を得る；3. 技術的深度とプロジェクト進捗のバランスを取る；4. プロジェクト管理スキルを学び、時間をより良く計画する。'
    },
    tags: ['缺点', '自我改进'],
    difficulty: 'medium'
  },

  // 职业规划
  {
    id: 'career-1',
    category: 'general',
    subcategory: 'career-goals',
    question: {
      zh: '你的职业规划是什么？',
      ja: 'あなたのキャリアプランは何ですか？'
    },
    answer: {
      zh: '我的职业规划分为短期和长期目标：短期目标（1-3年）：在当前技术领域深入发展，掌握更多前沿技术，承担更重要的项目责任；中期目标（3-5年）：成为技术专家或团队领导，能够指导初级开发者，参与架构设计决策；长期目标（5年以上）：希望成为技术总监或CTO，不仅具备深厚的技术背景，还能从业务角度思考技术方案，推动公司技术创新。',
      ja: '私のキャリアプランは短期と長期の目標に分かれます：短期目標（1-3年）：現在の技術分野で深く発展し、より多くの最先端技術を習得し、より重要なプロジェクトの責任を担う；中期目標（3-5年）：技術専門家またはチームリーダーとなり、初級開発者を指導し、アーキテクチャ設計の決定に参加する；長期目標（5年以上）：技術ディレクターまたはCTOとなり、深い技術的背景を持つだけでなく、ビジネスの観点から技術ソリューションを考え、会社の技術革新を推進したいと考えています。'
    },
    tags: ['职业规划', '目标设定'],
    difficulty: 'medium'
  },

  // === 日本企业特色问题 ===
  {
    id: 'japan-culture-1',
    category: 'japan-specific',
    question: {
      zh: '你对日本的工作文化有什么了解？',
      ja: '日本の職場文化についてどのようなことを知っていますか？'
    },
    answer: {
      zh: '我了解日本工作文化的几个特点：1. 团队协作 - 重视集体利益，强调"报连相"（报告、联络、商量）；2. 细致严谨 - 追求完美，注重细节和质量；3. 长期雇用 - 重视员工培养和公司忠诚度；4. 等级秩序 - 尊重上下级关系，重视礼仪；5. 持续改善 - "改善"文化，不断优化工作流程。我很期待能够融入这样的工作环境，学习日本的工作方式。',
      ja: '日本の職場文化の特徴をいくつか理解しています：1. チームワーク - 集団の利益を重視し、「ホウレンソウ」（報告・連絡・相談）を強調；2. 細心かつ厳密 - 完璧を追求し、細部と品質に注目；3. 長期雇用 - 従業員の育成と会社への忠誠心を重視；4. 階層秩序 - 上下関係を尊重し、礼儀を重視；5. 継続的改善 - 「カイゼン」文化で、作業プロセスを継続的に最適化。このような職場環境に溶け込み、日本の働き方を学ぶことを楽しみにしています。'
    },
    tags: ['日本文化', '工作文化'],
    difficulty: 'medium'
  },

  // === 技术面试问题 ===

  // Java开发类问题
  {
    id: 'tech-java-1',
    category: 'technical',
    subcategory: 'java',
    question: {
      zh: '请解释Java中的面向对象编程概念',
      ja: 'Javaのオブジェクト指向プログラミングの概念を説明してください'
    },
    answer: {
      zh: 'Java中的面向对象编程包含四个基本概念：1. 封装(Encapsulation) - 将数据和方法封装在类中，通过访问修饰符控制访问权限；2. 继承(Inheritance) - 子类可以继承父类的属性和方法，实现代码复用；3. 多态(Polymorphism) - 同一接口可以有不同的实现，运行时确定具体调用哪个实现；4. 抽象(Abstraction) - 通过抽象类和接口定义抽象概念，隐藏实现细节。',
      ja: 'Javaのオブジェクト指向プログラミングには4つの基本概念があります：1. カプセル化 - データとメソッドをクラス内に封じ込め、アクセス修飾子でアクセス権を制御；2. 継承 - 子クラスが親クラスの属性とメソッドを継承し、コードの再利用を実現；3. ポリモーフィズム - 同一インターフェースが異なる実装を持ち、実行時に具体的な実装を決定；4. 抽象化 - 抽象クラスとインターフェースで抽象概念を定義し、実装詳細を隠蔽。'
    },
    tags: ['Java', 'OOP', '基础概念'],
    difficulty: 'medium'
  },
  {
    id: 'tech-java-2',
    category: 'technical',
    subcategory: 'java',
    question: {
      zh: 'Java中的HashMap和ConcurrentHashMap有什么区别？',
      ja: 'JavaのHashMapとConcurrentHashMapの違いは何ですか？'
    },
    answer: {
      zh: '主要区别包括：1. 线程安全性 - HashMap不是线程安全的，ConcurrentHashMap是线程安全的；2. 性能 - HashMap在单线程环境下性能更好，ConcurrentHashMap在多线程环境下性能优异；3. 实现机制 - ConcurrentHashMap使用分段锁(Segment)或CAS操作来保证线程安全；4. Null值 - HashMap允许null key和null value，ConcurrentHashMap不允许；5. 迭代器 - HashMap的迭代器是fail-fast的，ConcurrentHashMap是fail-safe的。',
      ja: '主な違いは以下の通りです：1. スレッドセーフティ - HashMapはスレッドセーフではなく、ConcurrentHashMapはスレッドセーフです；2. パフォーマンス - HashMapは単一スレッド環境で優れ、ConcurrentHashMapはマルチスレッド環境で優秀です；3. 実装メカニズム - ConcurrentHashMapは分割ロック（Segment）やCAS操作でスレッドセーフを保証；4. Null値 - HashMapはnull keyとnull valueを許可し、ConcurrentHashMapは許可しません；5. イテレータ - HashMapのイテレータはfail-fast、ConcurrentHashMapはfail-safeです。'
    },
    tags: ['Java', 'HashMap', '并发编程'],
    difficulty: 'hard'
  },

  // 前端开发类问题
  {
    id: 'tech-frontend-1',
    category: 'technical',
    subcategory: 'frontend',
    question: {
      zh: 'React中的useEffect Hook有什么作用？如何正确使用？',
      ja: 'ReactのuseEffect Hookの役割は何ですか？正しい使い方は？'
    },
    answer: {
      zh: 'useEffect Hook用于处理副作用操作，包括：1. 数据获取 - API调用、订阅等；2. DOM操作 - 直接操作DOM元素；3. 定时器 - setTimeout、setInterval；4. 清理操作 - 组件卸载时的清理。正确使用方式：指定依赖数组来控制何时执行，返回清理函数避免内存泄漏，避免在effect中直接修改state导致无限循环。',
      ja: 'useEffect Hookは副作用操作を処理するために使用され、以下が含まれます：1. データ取得 - API呼び出し、サブスクリプションなど；2. DOM操作 - DOM要素の直接操作；3. タイマー - setTimeout、setInterval；4. クリーンアップ操作 - コンポーネントアンマウント時のクリーンアップ。正しい使用方法：依存配列を指定して実行タイミングを制御、クリーンアップ関数を返してメモリリークを防ぐ、effect内で直接stateを変更して無限ループを避ける。'
    },
    tags: ['React', 'Hook', '前端'],
    difficulty: 'medium'
  },
  {
    id: 'tech-frontend-2',
    category: 'technical',
    subcategory: 'frontend',
    question: {
      zh: '什么是虚拟DOM？它的优势是什么？',
      ja: 'Virtual DOMとは何ですか？その利点は何ですか？'
    },
    answer: {
      zh: '虚拟DOM是对真实DOM的JavaScript抽象表示。优势包括：1. 性能优化 - 通过diff算法最小化DOM操作；2. 批量更新 - 将多个变更合并为一次DOM更新；3. 跨浏览器兼容 - 抽象化处理浏览器差异；4. 可预测性 - 函数式编程思想，状态变化可预测；5. 开发体验 - 声明式编程，易于理解和维护；6. 服务端渲染 - 支持SSR，提升首屏加载速度。',
      ja: 'Virtual DOMは真のDOMのJavaScript抽象表現です。利点には以下があります：1. パフォーマンス最適化 - diffアルゴリズムでDOM操作を最小化；2. バッチ更新 - 複数の変更を一度のDOM更新にまとめる；3. クロスブラウザ互換性 - ブラウザの違いを抽象化；4. 予測可能性 - 関数型プログラミングの思想、状態変化が予測可能；5. 開発体験 - 宣言的プログラミング、理解と保守が容易；6. サーバーサイドレンダリング - SSRをサポート、初期画面読み込み速度を向上。'
    },
    tags: ['Virtual DOM', 'React', 'パフォーマンス'],
    difficulty: 'medium'
  },

  // 后端开发类问题
  {
    id: 'tech-backend-1',
    category: 'technical',
    subcategory: 'backend',
    question: {
      zh: '什么是RESTful API？请解释其设计原则',
      ja: 'RESTful APIとは何ですか？その設計原則を説明してください'
    },
    answer: {
      zh: 'RESTful API是基于REST架构风格的Web API。设计原则包括：1. 无状态 - 每个请求都包含处理所需的全部信息；2. 统一接口 - 使用标准HTTP方法(GET、POST、PUT、DELETE)；3. 资源标识 - 通过URI唯一标识资源；4. 资源表现 - 支持多种数据格式(JSON、XML)；5. 分层系统 - 客户端不需要知道是否连接到最终服务器；6. 可缓存 - 响应应该被标记为可缓存或不可缓存。',
      ja: 'RESTful APIはRESTアーキテクチャスタイルに基づくWeb APIです。設計原則には以下があります：1. ステートレス - 各リクエストに処理に必要な全情報を含む；2. 統一インターフェース - 標準HTTPメソッド（GET、POST、PUT、DELETE）を使用；3. リソース識別 - URIでリソースを一意に識別；4. リソース表現 - 複数のデータ形式（JSON、XML）をサポート；5. 階層システム - クライアントは最終サーバーに接続しているかを知る必要がない；6. キャッシュ可能 - レスポンスはキャッシュ可能または不可能としてマークされるべき。'
    },
    tags: ['REST', 'API設計', 'HTTP'],
    difficulty: 'medium'
  },
  {
    id: 'tech-backend-2',
    category: 'technical',
    subcategory: 'backend',
    question: {
      zh: '解释微服务架构的优缺点',
      ja: 'マイクロサービスアーキテクチャの長所と短所を説明してください'
    },
    answer: {
      zh: '微服务架构的优缺点：\n\n优点：\n1. 独立部署 - 每个服务可以独立开发、测试、部署\n2. 技术多样性 - 不同服务可以使用不同的技术栈\n3. 可扩展性 - 可以根据需求独立扩展特定服务\n4. 故障隔离 - 单个服务故障不会影响整个系统\n5. 团队自治 - 小团队可以独立负责特定服务\n\n缺点：\n1. 复杂性增加 - 分布式系统的复杂性\n2. 网络延迟 - 服务间通信开销\n3. 数据一致性 - 分布式事务处理困难\n4. 运维成本 - 需要更多的监控和管理工具',
      ja: 'マイクロサービスアーキテクチャの長所と短所：\n\n長所：\n1. 独立デプロイ - 各サービスを独立して開発、テスト、デプロイ可能\n2. 技術多様性 - 異なるサービスで異なる技術スタックを使用可能\n3. スケーラビリティ - 必要に応じて特定のサービスを独立してスケール\n4. 障害分離 - 単一サービスの障害がシステム全体に影響しない\n5. チーム自律性 - 小規模チームが特定のサービスを独立して担当\n\n短所：\n1. 複雑性の増加 - 分散システムの複雑性\n2. ネットワーク遅延 - サービス間通信のオーバーヘッド\n3. データ一貫性 - 分散トランザクション処理の困難\n4. 運用コスト - より多くの監視と管理ツールが必要'
    },
    tags: ['マイクロサービス', 'アーキテクチャ', 'システム設計'],
    difficulty: 'hard'
  },

  // 数据库技术类问题
  {
    id: 'tech-database-1',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: '请解释数据库事务的ACID特性',
      ja: 'データベーストランザクションのACID特性を説明してください'
    },
    answer: {
      zh: 'ACID是数据库事务的四个基本特性：1. 原子性(Atomicity) - 事务中的所有操作要么全部成功，要么全部失败回滚；2. 一致性(Consistency) - 事务执行前后数据库都处于一致状态；3. 隔离性(Isolation) - 并发执行的事务之间相互隔离，不会相互干扰；4. 持久性(Durability) - 事务一旦提交，其结果就永久保存在数据库中，即使系统故障也不会丢失。',
      ja: 'ACIDはデータベーストランザクションの4つの基本特性です：1. 原子性（Atomicity） - トランザクション内の全操作が成功するか、全て失敗してロールバック；2. 一貫性（Consistency） - トランザクション実行前後でデータベースが一貫した状態を保つ；3. 独立性（Isolation） - 並行実行されるトランザクション間が相互に隔離され、干渉しない；4. 永続性（Durability） - トランザクションが一度コミットされると、その結果はデータベースに永続的に保存され、システム障害でも失われない。'
    },
    tags: ['データベース', 'ACID', 'トランザクション'],
    difficulty: 'medium'
  },
  {
    id: 'tech-database-2',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: 'SQL和NoSQL数据库的区别是什么？',
      ja: 'SQLとNoSQLデータベースの違いは何ですか？'
    },
    answer: {
      zh: 'SQL和NoSQL数据库的主要区别：\n\nSQL数据库（关系型）：\n• 结构化数据，使用表格存储\n• ACID事务支持\n• 复杂查询和JOIN操作\n• 垂直扩展\n• 例如：MySQL、PostgreSQL、Oracle\n\nNoSQL数据库（非关系型）：\n• 非结构化数据，灵活的数据模型\n• 最终一致性\n• 简单查询，高性能\n• 水平扩展\n• 类型：文档型(MongoDB)、键值型(Redis)、列族型(Cassandra)、图型(Neo4j)',
      ja: 'SQLとNoSQLデータベースの主な違い：\n\nSQLデータベース（リレーショナル）：\n• 構造化データ、テーブルで保存\n• ACIDトランザクションサポート\n• 複雑なクエリとJOIN操作\n• 垂直スケーリング\n• 例：MySQL、PostgreSQL、Oracle\n\nNoSQLデータベース（非リレーショナル）：\n• 非構造化データ、柔軟なデータモデル\n• 結果整合性\n• シンプルなクエリ、高パフォーマンス\n• 水平スケーリング\n• 種類：ドキュメント型(MongoDB)、キーバリュー型(Redis)、カラム型(Cassandra)、グラフ型(Neo4j)'
    },
    tags: ['SQL', 'NoSQL', 'データベース比較'],
    difficulty: 'medium'
  },

  // 云计算技术类问题
  {
    id: 'tech-cloud-1',
    category: 'technical',
    subcategory: 'cloud',
    question: {
      zh: '什么是容器化？Docker相比虚拟机有什么优势？',
      ja: 'コンテナ化とは何ですか？Dockerは仮想マシンと比べてどんな利点がありますか？'
    },
    answer: {
      zh: '容器化是将应用程序及其依赖打包在轻量级、可移植的容器中的技术。Docker相比虚拟机的优势：1. 资源利用率高 - 共享主机OS内核，开销更小；2. 启动速度快 - 秒级启动，而VM需要分钟级；3. 可移植性强 - "一次构建，到处运行"；4. 部署简单 - 标准化的部署流程；5. 版本控制 - 支持镜像版本管理；6. 微服务友好 - 适合微服务架构部署。',
      ja: 'コンテナ化は、アプリケーションとその依存関係を軽量で移植可能なコンテナにパッケージ化する技術です。Dockerが仮想マシンと比べた利点：1. 高いリソース利用率 - ホストOSカーネルを共有し、オーバーヘッドが小さい；2. 高速起動 - 秒単位での起動、VMは分単位が必要；3. 高い移植性 - "一度ビルドすればどこでも実行"；4. 簡単なデプロイ - 標準化されたデプロイプロセス；5. バージョン管理 - イメージのバージョン管理をサポート；6. マイクロサービスフレンドリー - マイクロサービスアーキテクチャのデプロイに適している。'
    },
    tags: ['Docker', 'コンテナ', 'クラウド'],
    difficulty: 'medium'
  },
  {
    id: 'tech-cloud-2',
    category: 'technical',
    subcategory: 'cloud',
    question: {
      zh: '解释AWS的EC2、S3和RDS服务的用途',
      ja: 'AWSのEC2、S3、RDSサービスの用途を説明してください'
    },
    answer: {
      zh: 'AWS核心服务说明：\n\n1. EC2 (Elastic Compute Cloud)\n• 用途：提供可扩展的虚拟服务器\n• 特点：按需付费、多种实例类型、自动扩展\n• 适用场景：Web应用托管、计算密集型任务\n\n2. S3 (Simple Storage Service)\n• 用途：对象存储服务\n• 特点：无限存储空间、高可用性、多种存储类别\n• 适用场景：静态网站托管、备份、大数据分析\n\n3. RDS (Relational Database Service)\n• 用途：托管关系型数据库\n• 特点：自动备份、多可用区部署、性能监控\n• 适用场景：应用数据存储、事务处理系统',
      ja: 'AWSの核心サービスの説明：\n\n1. EC2 (Elastic Compute Cloud)\n• 用途：スケーラブルな仮想サーバーを提供\n• 特徴：オンデマンド課金、多様なインスタンスタイプ、自動スケーリング\n• 適用シーン：Webアプリケーションホスティング、計算集約的タスク\n\n2. S3 (Simple Storage Service)\n• 用途：オブジェクトストレージサービス\n• 特徴：無制限ストレージ、高可用性、多様なストレージクラス\n• 適用シーン：静的ウェブサイトホスティング、バックアップ、ビッグデータ分析\n\n3. RDS (Relational Database Service)\n• 用途：マネージドリレーショナルデータベース\n• 特徴：自動バックアップ、マルチAZ配置、パフォーマンス監視\n• 適用シーン：アプリケーションデータ保存、トランザクション処理システム'
    },
    tags: ['AWS', 'Cloud Services', '基础服务'],
    difficulty: 'medium'
  },

  // 系统设计类问题
  {
    id: 'tech-system-1',
    category: 'technical',
    subcategory: 'system-design',
    question: {
      zh: '如何设计一个高可用的Web系统？',
      ja: '高可用性のWebシステムをどのように設計しますか？'
    },
    answer: {
      zh: '设计高可用Web系统需要考虑：1. 负载均衡 - 使用LB分散请求，避免单点故障；2. 数据库集群 - 主从复制、读写分离、分库分表；3. 缓存策略 - Redis集群、CDN加速；4. 服务监控 - 实时监控、告警机制；5. 故障转移 - 自动failover机制；6. 容灾备份 - 多地域部署、数据备份；7. 限流熔断 - 保护系统免受突发流量冲击；8. 微服务架构 - 服务解耦，提高系统弹性。',
      ja: '高可用性Webシステムの設計では以下を考慮します：1. ロードバランシング - LBでリクエストを分散し、単一障害点を回避；2. データベースクラスタ - マスタースレーブレプリケーション、読み書き分離、シャーディング；3. キャッシュ戦略 - Redisクラスタ、CDN高速化；4. サービス監視 - リアルタイム監視、アラート機構；5. フェイルオーバー - 自動failover機構；6. 災害復旧 - マルチリージョンデプロイ、データバックアップ；7. レート制限・サーキットブレーカー - 突発的なトラフィックからシステムを保護；8. マイクロサービスアーキテクチャ - サービス分離でシステムの弾力性を向上。'
    },
    tags: ['システム設計', '高可用性', 'アーキテクチャ'],
    difficulty: 'hard'
  },

  // DevOps运维类问题
  {
    id: 'tech-devops-1',
    category: 'technical',
    subcategory: 'devops',
    question: {
      zh: '什么是CI/CD？请解释其流程和优势',
      ja: 'CI/CDとは何ですか？そのプロセスと利点を説明してください'
    },
    answer: {
      zh: 'CI/CD是持续集成和持续部署的简称：\n\nCI (持续集成)：\n• 开发者频繁地将代码合并到主分支\n• 每次提交都会触发自动化构建和测试\n• 快速发现集成问题\n\nCD (持续部署)：\n• 持续交付：代码自动部署到测试环境\n• 持续部署：代码自动部署到生产环境\n\n流程：代码提交 → 自动构建 → 自动测试 → 自动部署\n\n优势：提高开发效率、减少人为错误、快速反馈、提升软件质量',
      ja: 'CI/CDは継続的インテグレーションと継続的デプロイの略称です：\n\nCI (継続的インテグレーション)：\n• 開発者が頻繁にコードをメインブランチにマージ\n• 各コミットで自動化ビルドとテストをトリガー\n• 統合問題を迅速に発見\n\nCD (継続的デプロイ)：\n• 継続的デリバリ：コードを自動的にテスト環境にデプロイ\n• 継続的デプロイ：コードを自動的に本番環境にデプロイ\n\nプロセス：コードコミット → 自動ビルド → 自動テスト → 自動デプロイ\n\n利点：開発効率向上、人的エラー削減、迅速なフィードバック、ソフトウェア品質向上'
    },
    tags: ['CI/CD', 'DevOps', '自動化'],
    difficulty: 'medium'
  },

  // 网络安全类问题
  {
    id: 'tech-security-1',
    category: 'technical',
    subcategory: 'security',
    question: {
      zh: '常见的Web安全漏洞有哪些？如何防范？',
      ja: '一般的なWebセキュリティ脆弱性にはどのようなものがありますか？どのように防止しますか？'
    },
    answer: {
      zh: '常见Web安全漏洞及防范措施：\n\n1. SQL注入\n• 问题：恶意SQL代码注入\n• 防范：使用参数化查询、输入验证\n\n2. XSS (跨站脚本攻击)\n• 问题：注入恶意脚本\n• 防范：输入输出编码、CSP策略\n\n3. CSRF (跨站请求伪造)\n• 问题：伪造用户请求\n• 防范：CSRF token、同源检查\n\n4. 文件上传漏洞\n• 问题：上传恶意文件\n• 防范：文件类型检查、安全存储\n\n5. 认证授权问题\n• 问题：身份验证绕过\n• 防范：强密码策略、多因子认证',
      ja: '一般的なWebセキュリティ脆弱性と対策：\n\n1. SQLインジェクション\n• 問題：悪意のあるSQLコードの注入\n• 対策：パラメータ化クエリ、入力検証を使用\n\n2. XSS (クロスサイトスクリプティング)\n• 問題：悪意のあるスクリプトの注入\n• 対策：入出力エンコーディング、CSPポリシー\n\n3. CSRF (クロスサイトリクエストフォージェリ)\n• 問題：ユーザーリクエストの偽造\n• 対策：CSRFトークン、同一オリジンチェック\n\n4. ファイルアップロード脆弱性\n• 問題：悪意のあるファイルのアップロード\n• 対策：ファイルタイプチェック、安全な保存\n\n5. 認証・認可の問題\n• 問題：認証の回避\n• 対策：強力なパスワードポリシー、多要素認証'
    },
    tags: ['セキュリティ', '脆弱性', 'Web安全'],
    difficulty: 'hard'
  },

  // 算法数据结构类问题
  {
    id: 'tech-algorithms-1',
    category: 'technical',
    subcategory: 'algorithms',
    question: {
      zh: '请解释时间复杂度和空间复杂度的概念',
      ja: '時間計算量と空間計算量の概念を説明してください'
    },
    answer: {
      zh: '时间复杂度和空间复杂度是衡量算法效率的两个重要指标：\n\n时间复杂度：\n• 定义：算法执行时间随输入规模增长的变化率\n• 常见复杂度：O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ)\n• 分析方法：关注循环次数、递归深度\n\n空间复杂度：\n• 定义：算法执行时所需额外内存空间随输入规模的变化率\n• 包括：辅助空间、递归栈空间\n• 目标：在满足时间要求下尽量减少空间使用\n\n分析原则：\n• 最坏情况分析\n• 忽略常数因子\n• 关注主要增长趋势',
      ja: '時間計算量と空間計算量はアルゴリズムの効率を測る2つの重要な指標です：\n\n時間計算量：\n• 定義：入力サイズの増加に伴うアルゴリズム実行時間の変化率\n• 一般的な計算量：O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ)\n• 分析方法：ループ回数、再帰の深さに注目\n\n空間計算量：\n• 定義：入力サイズの増加に伴う追加メモリ空間の変化率\n• 含まれるもの：補助空間、再帰スタック空間\n• 目標：時間要件を満たしながら空間使用量を最小化\n\n分析原則：\n• 最悪ケース分析\n• 定数係数は無視\n• 主要な増加傾向に注目'
    },
    tags: ['アルゴリズム', '計算量', 'パフォーマンス'],
    difficulty: 'medium'
  }
] 