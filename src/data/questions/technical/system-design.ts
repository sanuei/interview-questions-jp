import { Question } from '@/types'

export const systemDesignQuestions: Question[] = [
  {
    id: 'system-design-1',
    category: 'technical',
    subcategory: 'system-design',
    question: {
      zh: '如何设计一个高并发的秒杀系统？',
      ja: '高並行性のフラッシュセールシステムをどのように設計しますか？'
    },
    answer: {
      zh: '秒杀系统的核心是处理瞬间大量请求。设计要点：1）前端限流，按钮置灰、验证码、排队页面；2）CDN加速，静态资源缓存；3）负载均衡，分散请求到多个服务器；4）缓存预热，提前将商品信息加载到Redis；5）库存扣减，使用Redis原子操作或数据库乐观锁；6）异步处理，下单后异步处理支付和发货；7）数据库优化，读写分离、分库分表；8）限流熔断，防止系统崩溃。关键是要分层限流，从前端到后端都要有保护机制。',
      ja: 'フラッシュセールシステムの核心は、瞬間的な大量リクエストを処理することです。設計ポイント：1）フロントエンド制限、ボタングレーアウト、認証コード、キューページ；2）CDN加速、静的リソースキャッシュ；3）ロードバランシング、リクエストを複数のサーバーに分散；4）キャッシュプリヒート、商品情報を事前にRedisに読み込み；5）在庫削減、Redisアトミック操作またはデータベース楽観的ロック使用；6）非同期処理、注文後に支払いと発送を非同期処理；7）データベース最適化、読み書き分離、シャーディング；8）制限・サーキットブレーカー、システムクラッシュを防止。重要なのは階層的制限で、フロントエンドからバックエンドまで保護機構が必要です。'
    },
    tags: ['高并发', '秒杀系统', '系统架构'],
    difficulty: 'hard'
  },
  {
    id: 'system-design-2',
    category: 'technical',
    subcategory: 'system-design',
    question: {
      zh: '如何设计一个分布式缓存系统？',
      ja: '分散キャッシュシステムをどのように設計しますか？'
    },
    answer: {
      zh: '分布式缓存系统的设计要考虑几个方面：1）数据分片，使用一致性哈希算法分配数据到不同节点；2）数据复制，每个数据有多个副本保证高可用；3）故障处理，节点失效时自动切换到备份节点；4）数据一致性，使用最终一致性模型；5）缓存策略，LRU、LFU等淘汰算法；6）序列化，选择高效的序列化方式；7）网络通信，使用高性能的网络协议；8）监控告警，实时监控系统状态。关键是要平衡性能、一致性和可用性，根据业务需求选择合适的策略。',
      ja: '分散キャッシュシステムの設計では、いくつかの側面を考慮する必要があります：1）データシャーディング、一貫性ハッシュアルゴリズムを使用してデータを異なるノードに分配；2）データレプリケーション、各データに複数のレプリカを持って高可用性を保証；3）障害処理、ノード障害時に自動的にバックアップノードに切り替え；4）データ一貫性、最終一貫性モデルを使用；5）キャッシュ戦略、LRU、LFUなどの削除アルゴリズム；6）シリアライゼーション、効率的なシリアライゼーション方式を選択；7）ネットワーク通信、高性能ネットワークプロトコルを使用；8）監視・アラート、システム状態をリアルタイムで監視。重要なのは、パフォーマンス、一貫性、可用性のバランスを取り、ビジネスニーズに応じて適切な戦略を選択することです。'
    },
    tags: ['分布式缓存', '一致性哈希', '高可用'],
    difficulty: 'hard'
  },
  {
    id: 'system-design-3',
    category: 'technical',
    subcategory: 'system-design',
    question: {
      zh: '如何设计一个消息队列系统？',
      ja: 'メッセージキューシステムをどのように設计しますか？'
    },
    answer: {
      zh: '消息队列系统的设计要点：1）消息存储，使用磁盘持久化保证消息不丢失；2）消息分发，支持点对点和发布订阅模式；3）消息顺序，保证同一主题的消息按顺序处理；4）消息确认，消费者处理完消息后发送确认；5）重试机制，消息处理失败时自动重试；6）死信队列，处理无法消费的消息；7）集群部署，多个节点保证高可用；8）监控管理，实时监控队列状态。关键是要保证消息的可靠性传输，防止消息丢失和重复消费。',
      ja: 'メッセージキューシステムの設計ポイント：1）メッセージストレージ、ディスク永続化を使用してメッセージ損失を防止；2）メッセージ配信、ポイントツーポイントとパブリッシュサブスクライブモードをサポート；3）メッセージ順序、同じトピックのメッセージを順番に処理することを保証；4）メッセージ確認、コンシューマーがメッセージ処理後に確認を送信；5）リトライメカニズム、メッセージ処理失敗時に自動リトライ；6）デッドレターキュー、消費できないメッセージを処理；7）クラスター展開、複数のノードで高可用性を保証；8）監視管理、キューの状態をリアルタイムで監視。重要なのは、メッセージの信頼性伝送を保証し、メッセージ損失と重複消費を防ぐことです。'
    },
    tags: ['消息队列', '异步处理', '系统解耦'],
    difficulty: 'hard'
  },
  {
    id: 'system-design-4',
    category: 'technical',
    subcategory: 'system-design',
    question: {
      zh: '如何设计一个短链接系统（如bit.ly）？',
      ja: '短縮URLシステム（bit.lyなど）をどのように設計しますか？'
    },
    answer: {
      zh: '短链接系统的设计：1）URL编码，使用Base62编码生成短链接；2）数据存储，使用数据库存储长短链接映射关系；3）缓存优化，热点链接放入Redis缓存；4）负载均衡，多个服务器处理请求；5）统计分析，记录点击次数、地理位置等信息；6）过期处理，支持链接过期时间设置；7）自定义短链，允许用户自定义短链接；8）安全防护，防止恶意链接和爬虫。核心算法是将长URL转换为短码，可以使用数据库自增ID+Base62编码，或者使用哈希算法。',
      ja: '短縮URLシステムの設計：1）URL符号化、Base62符号化を使用して短縮URLを生成；2）データストレージ、データベースを使用して長短URL間のマッピング関係を保存；3）キャッシュ最適化、ホットリンクをRedisキャッシュに配置；4）ロードバランシング、複数のサーバーでリクエストを処理；5）統計分析、クリック数、地理的位置などの情報を記録；6）有効期限処理、リンクの有効期限設定をサポート；7）カスタム短縮URL、ユーザーがカスタム短縮URLを作成可能；8）セキュリティ保護、悪意のあるリンクとクローラーを防止。核心アルゴリズムは長いURLを短いコードに変換することで、データベース自動増分ID+Base62符号化、またはハッシュアルゴリズムを使用できます。'
    },
    tags: ['短链接', 'URL编码', '系统设计'],
    difficulty: 'medium'
  },
  {
    id: 'system-design-5',
    category: 'technical',
    subcategory: 'system-design',
    question: {
      zh: '如何设计一个聊天系统？',
      ja: 'チャットシステムをどのように設計しますか？'
    },
    answer: {
      zh: '聊天系统的设计要点：1）实时通信，使用WebSocket或长轮询实现实时消息传输；2）消息存储，使用数据库存储聊天记录；3）用户管理，用户登录、好友关系管理；4）群组功能，支持群聊和私聊；5）消息推送，离线用户的消息推送；6）文件传输，支持图片、文件等多媒体消息；7）消息同步，多设备间消息同步；8）安全加密，消息传输加密保护隐私。技术选型：前端用React/Vue，后端用Node.js/Java，数据库用MySQL/MongoDB，缓存用Redis，消息队列用RabbitMQ。',
      ja: 'チャットシステムの設計ポイント：1）リアルタイム通信、WebSocketまたはロングポーリングを使用してリアルタイムメッセージ伝送を実現；2）メッセージストレージ、データベースを使用してチャット履歴を保存；3）ユーザー管理、ユーザーログイン、友達関係管理；4）グループ機能、グループチャットとプライベートチャットをサポート；5）メッセージプッシュ、オフラインユーザーへのメッセージプッシュ；6）ファイル転送、画像、ファイルなどマルチメディアメッセージをサポート；7）メッセージ同期、複数デバイス間でのメッセージ同期；8）セキュリティ暗号化、メッセージ伝送暗号化でプライバシーを保護。技術選択：フロントエンドはReact/Vue、バックエンドはNode.js/Java、データベースはMySQL/MongoDB、キャッシュはRedis、メッセージキューはRabbitMQ。'
    },
    tags: ['实时通信', 'WebSocket', '消息系统'],
    difficulty: 'hard'
  },
  {
    id: 'system-design-6',
    category: 'technical',
    subcategory: 'system-design',
    question: {
      zh: '如何设计一个搜索引擎？',
      ja: '検索エンジンをどのように設計しますか？'
    },
    answer: {
      zh: '搜索引擎的设计包括几个核心模块：1）网页爬虫，抓取互联网上的网页内容；2）内容解析，提取网页的标题、正文、链接等信息；3）索引构建，建立倒排索引加速搜索；4）排名算法，根据相关性和权重排序搜索结果；5）查询处理，解析用户查询词，支持模糊搜索；6）结果展示，分页显示搜索结果；7）缓存优化，缓存热门搜索结果；8）分布式架构，处理海量数据和高并发查询。技术栈：爬虫用Python/Java，索引用Elasticsearch/Solr，存储用分布式数据库，缓存用Redis。',
      ja: '検索エンジンの設計には、いくつかの核心モジュールが含まれます：1）ウェブクローラー、インターネット上のウェブページコンテンツを取得；2）コンテンツ解析、ウェブページのタイトル、本文、リンクなどの情報を抽出；3）インデックス構築、逆インデックスを構築して検索を高速化；4）ランキングアルゴリズム、関連性と重みに基づいて検索結果をソート；5）クエリ処理、ユーザークエリワードを解析し、あいまい検索をサポート；6）結果表示、検索結果をページ分割表示；7）キャッシュ最適化、人気検索結果をキャッシュ；8）分散アーキテクチャ、大量データと高並行クエリを処理。技術スタック：クローラーはPython/Java、インデックスはElasticsearch/Solr、ストレージは分散データベース、キャッシュはRedis。'
    },
    tags: ['搜索引擎', '倒排索引', '分布式系统'],
    difficulty: 'hard'
  },
  {
    id: 'system-design-7',
    category: 'technical',
    subcategory: 'system-design',
    question: {
      zh: '如何设计一个限流系统？',
      ja: 'レート制限システムをどのように設計しますか？'
    },
    answer: {
      zh: '限流系统的设计要考虑几种算法：1）固定窗口，固定时间内允许固定数量请求；2）滑动窗口，更平滑的限流效果；3）令牌桶，以固定速率产生令牌，请求消耗令牌；4）漏桶算法，以固定速率处理请求，超出的请求被丢弃。实现方式：单机限流用内存计数器，分布式限流用Redis；可以按IP、用户、接口等维度限流；支持不同的限流策略，如拒绝、排队、降级。部署位置：网关层、应用层、数据库层都可以部署限流。关键是要根据业务场景选择合适的算法和策略。',
      ja: 'レート制限システムの設計では、いくつかのアルゴリズムを考慮する必要があります：1）固定ウィンドウ、固定時間内に固定数のリクエストを許可；2）スライディングウィンドウ、よりスムーズなレート制限効果；3）トークンバケット、固定レートでトークンを生成し、リクエストがトークンを消費；4）リーキーバケットアルゴリズム、固定レートでリクエストを処理し、超過したリクエストは破棄。実装方法：シングルマシンレート制限はメモリカウンターを使用、分散レート制限はRedisを使用；IP、ユーザー、インターフェースなどの次元でレート制限可能；拒否、キュー、ダウングレードなど異なるレート制限戦略をサポート。展開位置：ゲートウェイ層、アプリケーション層、データベース層すべてでレート制限を展開可能。重要なのは、ビジネスシナリオに応じて適切なアルゴリズムと戦略を選択することです。'
    },
    tags: ['限流', '令牌桶', '系统保护'],
    difficulty: 'medium'
  },
  {
    id: 'system-design-8',
    category: 'technical',
    subcategory: 'system-design',
    question: {
      zh: '如何设计一个推荐系统？',
      ja: '推薦システムをどのように設計しますか？'
    },
    answer: {
      zh: '推荐系统的设计包括几个核心组件：1）数据收集，收集用户行为数据（点击、购买、评分等）；2）用户画像，分析用户兴趣和偏好；3）内容画像，提取物品特征信息；4）推荐算法，协同过滤、内容推荐、深度学习等；5）实时计算，实时更新推荐结果；6）A/B测试，测试不同算法效果；7）冷启动，处理新用户和新物品；8）多样性和新鲜度，避免推荐结果过于单一。技术架构：离线计算用Spark/Hadoop，实时计算用Storm/Flink，存储用HBase/MongoDB，缓存用Redis。',
      ja: '推薦システムの設計には、いくつかの核心コンポーネントが含まれます：1）データ収集、ユーザー行動データ（クリック、購入、評価など）を収集；2）ユーザープロファイル、ユーザーの興味と好みを分析；3）コンテンツプロファイル、アイテムの特徴情報を抽出；4）推薦アルゴリズム、協調フィルタリング、コンテンツ推薦、深層学習など；5）リアルタイム計算、推薦結果をリアルタイムで更新；6）A/Bテスト、異なるアルゴリズムの効果をテスト；7）コールドスタート、新しいユーザーと新しいアイテムを処理；8）多様性と新鮮さ、推薦結果が単調になることを避ける。技術アーキテクチャ：オフライン計算はSpark/Hadoop、リアルタイム計算はStorm/Flink、ストレージはHBase/MongoDB、キャッシュはRedis。'
    },
    tags: ['推荐系统', '协同过滤', '机器学习'],
    difficulty: 'hard'
  },
  {
    id: 'system-design-9',
    category: 'technical',
    subcategory: 'system-design',
    question: {
      zh: '如何设计一个分布式ID生成系统？',
      ja: '分散ID生成システムをどのように設計しますか？'
    },
    answer: {
      zh: '分布式ID生成系统的设计方案：1）数据库自增ID，简单但性能有限；2）UUID，全局唯一但无序且较长；3）雪花算法（Snowflake），64位ID包含时间戳、机器ID、序列号；4）Redis原子递增，性能好但依赖Redis；5）号段模式，预分配ID段减少数据库访问；6）时间戳+机器码+序列号，自定义算法。选择标准：全局唯一性、高性能、有序性、高可用性。推荐雪花算法，既保证唯一性又有一定的有序性，性能也很好。需要考虑时钟回拨、机器ID分配等问题。',
      ja: '分散ID生成システムの設計方案：1）データベース自動増分ID、シンプルだが性能が限定的；2）UUID、グローバルに一意だが無秩序で長い；3）スノーフレークアルゴリズム（Snowflake）、64ビットIDにタイムスタンプ、マシンID、シーケンス番号を含む；4）Redisアトミック増分、性能が良いがRedisに依存；5）セグメントモード、ID段を事前割り当てしてデータベースアクセスを削減；6）タイムスタンプ+マシンコード+シーケンス番号、カスタムアルゴリズム。選択基準：グローバル一意性、高性能、順序性、高可用性。スノーフレークアルゴリズムを推奨、一意性を保証し、ある程度の順序性もあり、性能も良い。時計の逆行、マシンID割り当てなどの問題を考慮する必要があります。'
    },
    tags: ['分布式ID', '雪花算法', '唯一标识'],
    difficulty: 'medium'
  },
  {
    id: 'system-design-10',
    category: 'technical',
    subcategory: 'system-design',
    question: {
      zh: '如何设计一个日志系统？',
      ja: 'ログシステムをどのように設計しますか？'
    },
    answer: {
      zh: '日志系统的设计要点：1）日志收集，使用Agent收集各个服务的日志；2）日志传输，使用Kafka等消息队列传输日志；3）日志存储，使用Elasticsearch存储和索引日志；4）日志分析，使用Kibana等工具分析日志；5）日志清理，定期清理过期日志；6）日志格式，统一日志格式便于解析；7）日志级别，区分DEBUG、INFO、WARN、ERROR等级别；8）监控告警，根据日志内容设置告警规则。架构：ELK（Elasticsearch+Logstash+Kibana）或EFK（Elasticsearch+Fluentd+Kibana）。关键是要保证日志的完整性和实时性。',
      ja: 'ログシステムの設計ポイント：1）ログ収集、Agentを使用して各サービスのログを収集；2）ログ伝送、Kafkaなどメッセージキューを使用してログを伝送；3）ログストレージ、Elasticsearchを使用してログを保存・インデックス化；4）ログ分析、Kibanaなどツールを使用してログを分析；5）ログクリーンアップ、期限切れログを定期的にクリーンアップ；6）ログフォーマット、統一ログフォーマットで解析を容易化；7）ログレベル、DEBUG、INFO、WARN、ERRORなどのレベルを区別；8）監視・アラート、ログ内容に基づいてアラートルールを設定。アーキテクチャ：ELK（Elasticsearch+Logstash+Kibana）またはEFK（Elasticsearch+Fluentd+Kibana）。重要なのは、ログの完全性とリアルタイム性を保証することです。'
    },
    tags: ['日志系统', 'ELK', '日志分析'],
    difficulty: 'medium'
  }
] 