import { Question } from '@/types'

export const algorithmsQuestions: Question[] = [
  {
    id: 'algorithms-1',
    category: 'technical',
    subcategory: 'algorithms',
    question: {
      zh: '什么是时间复杂度和空间复杂度？常见的复杂度有哪些？',
      ja: '時間計算量と空間計算量とは何ですか？一般的な計算量は何ですか？'
    },
    answer: {
      zh: '时间复杂度是算法执行时间随输入规模增长的趋势，空间复杂度是算法占用内存空间随输入规模增长的趋势。常见时间复杂度：O(1)常数时间，如数组访问；O(log n)对数时间，如二分查找；O(n)线性时间，如遍历数组；O(n log n)，如归并排序；O(n²)平方时间，如冒泡排序；O(2^n)指数时间，如递归求斐波那契数列。一般来说，O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n)。分析复杂度时要看最坏情况下的表现。',
      ja: '時間計算量は、アルゴリズムの実行時間が入力規模の増加に伴って増長する傾向で、空間計算量は、アルゴリズムが占有するメモリ空間が入力規模の増加に伴って増長する傾向です。一般的な時間計算量：O(1)定数時間、配列アクセスなど；O(log n)対数時間、二分探索など；O(n)線形時間、配列の走査など；O(n log n)、マージソートなど；O(n²)平方時間、バブルソートなど；O(2^n)指数時間、再帰でフィボナッチ数列を求めるなど。一般的に、O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n)。計算量を分析する際は、最悪の場合の性能を見る必要があります。'
    },
    tags: ['时间复杂度', '空间复杂度', '算法分析'],
    difficulty: 'medium'
  },
  {
    id: 'algorithms-2',
    category: 'technical',
    subcategory: 'algorithms',
    question: {
      zh: '什么是排序算法？常见的排序算法有哪些？',
      ja: 'ソートアルゴリズムとは何ですか？一般的なソートアルゴリズムは何ですか？'
    },
    answer: {
      zh: '排序算法是将一组数据按照特定顺序排列的算法。常见排序算法：1）冒泡排序，相邻元素比较交换，时间复杂度O(n²)；2）选择排序，每次选择最小元素，时间复杂度O(n²)；3）插入排序，将元素插入到已排序部分，时间复杂度O(n²)；4）归并排序，分治法，时间复杂度O(n log n)；5）快速排序，选择基准元素分割，平均时间复杂度O(n log n)；6）堆排序，使用堆数据结构，时间复杂度O(n log n)。稳定性：归并排序、插入排序是稳定的，快速排序、堆排序是不稳定的。',
      ja: 'ソートアルゴリズムは、データのグループを特定の順序で並べるアルゴリズムです。一般的なソートアルゴリズム：1）バブルソート、隣接要素を比較交換、時間計算量O(n²)；2）選択ソート、毎回最小要素を選択、時間計算量O(n²)；3）挿入ソート、要素を既にソートされた部分に挿入、時間計算量O(n²)；4）マージソート、分割統治法、時間計算量O(n log n)；5）クイックソート、基準要素を選択して分割、平均時間計算量O(n log n)；6）ヒープソート、ヒープデータ構造を使用、時間計算量O(n log n)。安定性：マージソート、挿入ソートは安定、クイックソート、ヒープソートは不安定。'
    },
    tags: ['排序算法', '冒泡排序', '快速排序', '归并排序'],
    difficulty: 'medium'
  },
  {
    id: 'algorithms-3',
    category: 'technical',
    subcategory: 'algorithms',
    question: {
      zh: '什么是二分查找？如何实现二分查找？',
      ja: '二分探索とは何ですか？二分探索をどのように実装しますか？'
    },
    answer: {
      zh: '二分查找是在有序数组中查找特定元素的高效算法。原理：每次比较中间元素，如果目标值小于中间元素，在左半部分查找；如果大于中间元素，在右半部分查找；如果等于中间元素，找到目标。时间复杂度O(log n)，空间复杂度O(1)。实现要点：1）数组必须有序；2）使用左右指针；3）计算中间位置时注意溢出；4）循环条件是left <= right；5）更新指针时要注意边界。二分查找的变种：查找第一个等于目标值的位置、查找最后一个等于目标值的位置等。',
      ja: '二分探索は、ソート済み配列で特定の要素を探す効率的なアルゴリズムです。原理：毎回中間要素と比較し、目標値が中間要素より小さければ左半分で探索；大きければ右半分で探索；等しければ目標を発見。時間計算量O(log n)、空間計算量O(1)。実装ポイント：1）配列は必ずソート済み；2）左右ポインターを使用；3）中間位置計算時にオーバーフローに注意；4）ループ条件はleft <= right；5）ポインター更新時に境界に注意。二分探索の変種：目標値と等しい最初の位置を探す、目標値と等しい最後の位置を探すなど。'
    },
    tags: ['二分查找', '查找算法', '有序数组'],
    difficulty: 'medium'
  },
  {
    id: 'algorithms-4',
    category: 'technical',
    subcategory: 'algorithms',
    question: {
      zh: '什么是动态规划？如何解决动态规划问题？',
      ja: '動的プログラミングとは何ですか？動的プログラミング問題をどのように解決しますか？'
    },
    answer: {
      zh: '动态规划是通过将复杂问题分解为子问题，并存储子问题的解来避免重复计算的算法思想。核心特征：1）最优子结构，问题的最优解包含子问题的最优解；2）重叠子问题，子问题会被多次计算；3）无后效性，当前状态不受未来状态影响。解题步骤：1）定义状态，确定dp数组的含义；2）状态转移方程，找出状态之间的关系；3）初始化，设置边界条件；4）计算顺序，确定计算的顺序；5）返回结果。经典问题：斐波那契数列、爬楼梯、背包问题、最长公共子序列等。',
      ja: '動的プログラミングは、複雑な問題を部分問題に分解し、部分問題の解を保存して重複計算を避けるアルゴリズム思想です。核心特徴：1）最適部分構造、問題の最適解が部分問題の最適解を含む；2）重複部分問題、部分問題が複数回計算される；3）無後効性、現在の状態が将来の状態に影響されない。解題ステップ：1）状態定義、dp配列の意味を確定；2）状態遷移方程式、状態間の関係を見つける；3）初期化、境界条件を設定；4）計算順序、計算の順序を確定；5）結果を返す。古典的問題：フィボナッチ数列、階段登り、ナップサック問題、最長共通部分列など。'
    },
    tags: ['动态规划', '最优化', '递推'],
    difficulty: 'hard'
  },
  {
    id: 'algorithms-5',
    category: 'technical',
    subcategory: 'algorithms',
    question: {
      zh: '什么是递归？递归的优缺点是什么？',
      ja: '再帰とは何ですか？再帰の利点と欠点は何ですか？'
    },
    answer: {
      zh: '递归是函数调用自身的编程技巧，通过将大问题分解为小问题来解决。递归的要素：1）基本情况（递归终止条件）；2）递归情况（函数调用自身）；3）问题规模缩小。优点：代码简洁，逻辑清晰，适合处理分治问题；缺点：可能导致栈溢出，重复计算多，性能较差。优化方法：1）尾递归优化；2）记忆化递归（缓存结果）；3）转换为迭代。经典递归问题：阶乘、斐波那契数列、汉诺塔、树的遍历、快速排序等。使用递归时要注意栈深度限制。',
      ja: '再帰は関数が自分自身を呼び出すプログラミング技法で、大きな問題を小さな問題に分解して解決します。再帰の要素：1）基本ケース（再帰終了条件）；2）再帰ケース（関数が自分自身を呼び出す）；3）問題規模の縮小。利点：コードが簡潔、論理が明確、分割統治問題の処理に適している；欠点：スタックオーバーフローを引き起こす可能性、重複計算が多い、性能が劣る。最適化方法：1）末尾再帰最適化；2）メモ化再帰（結果をキャッシュ）；3）反復に変換。古典的再帰問題：階乗、フィボナッチ数列、ハノイの塔、木の走査、クイックソートなど。再帰使用時はスタック深度制限に注意が必要です。'
    },
    tags: ['递归', '分治', '栈溢出'],
    difficulty: 'medium'
  },
  {
    id: 'algorithms-6',
    category: 'technical',
    subcategory: 'algorithms',
    question: {
      zh: '什么是数据结构？常见的数据结构有哪些？',
      ja: 'データ構造とは何ですか？一般的なデータ構造は何ですか？'
    },
    answer: {
      zh: '数据结构是计算机存储、组织数据的方式。常见数据结构：1）数组，连续内存存储，随机访问O(1)；2）链表，节点通过指针连接，插入删除O(1)；3）栈，后进先出（LIFO），用于函数调用、表达式求值；4）队列，先进先出（FIFO），用于任务调度、BFS；5）哈希表，键值对存储，平均查找O(1)；6）树，层次结构，如二叉树、AVL树、红黑树；7）图，顶点和边的集合，用于网络、路径问题；8）堆，完全二叉树，用于优先队列。选择数据结构要考虑操作需求和性能要求。',
      ja: 'データ構造は、コンピューターがデータを保存・組織する方式です。一般的なデータ構造：1）配列、連続メモリ保存、ランダムアクセスO(1)；2）リンクリスト、ノードをポインターで接続、挿入削除O(1)；3）スタック、後入先出（LIFO）、関数呼び出し、式評価に使用；4）キュー、先入先出（FIFO）、タスクスケジューリング、BFSに使用；5）ハッシュテーブル、キー値ペア保存、平均検索O(1)；6）木、階層構造、二分木、AVL木、赤黒木など；7）グラフ、頂点と辺の集合、ネットワーク、経路問題に使用；8）ヒープ、完全二分木、優先度キューに使用。データ構造の選択は、操作ニーズと性能要求を考慮する必要があります。'
    },
    tags: ['数据结构', '数组', '链表', '栈', '队列'],
    difficulty: 'medium'
  },
  {
    id: 'algorithms-7',
    category: 'technical',
    subcategory: 'algorithms',
    question: {
      zh: '什么是二叉树？二叉树的遍历方式有哪些？',
      ja: '二分木とは何ですか？二分木の走査方法は何ですか？'
    },
    answer: {
      zh: '二叉树是每个节点最多有两个子节点的树结构，分为左子树和右子树。遍历方式：1）前序遍历（根-左-右），先访问根节点，再访问左子树，最后访问右子树；2）中序遍历（左-根-右），先访问左子树，再访问根节点，最后访问右子树；3）后序遍历（左-右-根），先访问左子树，再访问右子树，最后访问根节点；4）层序遍历，按层次从上到下、从左到右访问。实现方式：递归实现简单直观，迭代实现使用栈（前中后序）或队列（层序）。中序遍历二叉搜索树可以得到有序序列。',
      ja: '二分木は、各ノードが最大2つの子ノードを持つ木構造で、左部分木と右部分木に分かれます。走査方法：1）前順走査（根-左-右）、まず根ノードを訪問し、次に左部分木、最後に右部分木；2）中順走査（左-根-右）、まず左部分木を訪問し、次に根ノード、最後に右部分木；3）後順走査（左-右-根）、まず左部分木を訪問し、次に右部分木、最後に根ノード；4）レベル順走査、レベルごとに上から下、左から右に訪問。実装方法：再帰実装は簡潔で直感的、反復実装はスタック（前中後順）またはキュー（レベル順）を使用。二分探索木の中順走査でソート済みシーケンスを得ることができます。'
    },
    tags: ['二叉树', '树遍历', '前序', '中序', '后序'],
    difficulty: 'medium'
  },
  {
    id: 'algorithms-8',
    category: 'technical',
    subcategory: 'algorithms',
    question: {
      zh: '什么是图算法？常见的图算法有哪些？',
      ja: 'グラフアルゴリズムとは何ですか？一般的なグラフアルゴリズムは何ですか？'
    },
    answer: {
      zh: '图算法是处理图结构数据的算法，图由顶点和边组成。常见图算法：1）深度优先搜索（DFS），使用栈或递归，用于路径查找、连通性检测；2）广度优先搜索（BFS），使用队列，用于最短路径、层次遍历；3）最短路径算法，如Dijkstra算法（单源最短路径）、Floyd算法（所有顶点对最短路径）；4）最小生成树算法，如Kruskal算法、Prim算法；5）拓扑排序，用于有向无环图的线性排序；6）强连通分量算法，如Tarjan算法。图的表示方法：邻接矩阵、邻接表。',
      ja: 'グラフアルゴリズムは、グラフ構造データを処理するアルゴリズムで、グラフは頂点と辺で構成されます。一般的なグラフアルゴリズム：1）深さ優先探索（DFS）、スタックまたは再帰を使用、経路探索、連結性検出に使用；2）幅優先探索（BFS）、キューを使用、最短経路、レベル走査に使用；3）最短経路アルゴリズム、Dijkstraアルゴリズム（単一始点最短経路）、Floydアルゴリズム（全頂点対最短経路）など；4）最小全域木アルゴリズム、Kruskalアルゴリズム、Primアルゴリズムなど；5）トポロジカルソート、有向非循環グラフの線形順序に使用；6）強連結成分アルゴリズム、Tarjanアルゴリズムなど。グラフの表現方法：隣接行列、隣接リスト。'
    },
    tags: ['图算法', 'DFS', 'BFS', '最短路径'],
    difficulty: 'hard'
  },
  {
    id: 'algorithms-9',
    category: 'technical',
    subcategory: 'algorithms',
    question: {
      zh: '什么是贪心算法？贪心算法的特点是什么？',
      ja: '貪欲アルゴリズムとは何ですか？貪欲アルゴリズムの特徴は何ですか？'
    },
    answer: {
      zh: '贪心算法是在每一步选择中都采取当前状态下最好或最优的选择，从而希望导致结果是全局最好或最优的算法。特点：1）局部最优选择，每步都选择当前最优解；2）无后效性，当前选择不会影响之前的选择；3）不一定能得到全局最优解，但在某些问题上可以。适用条件：1）贪心选择性质，局部最优选择能导致全局最优解；2）最优子结构，问题的最优解包含子问题的最优解。经典问题：活动选择问题、分数背包问题、霍夫曼编码、最小生成树等。贪心算法简单高效，但要证明其正确性。',
      ja: '貪欲アルゴリズムは、各ステップの選択で現在の状態下で最良または最適な選択を行い、結果が全体的に最良または最適になることを期待するアルゴリズムです。特徴：1）局所最適選択、各ステップで現在の最適解を選択；2）無後効性、現在の選択が以前の選択に影響しない；3）必ずしも全体最適解を得られないが、特定の問題では可能。適用条件：1）貪欲選択性質、局所最適選択が全体最適解につながる；2）最適部分構造、問題の最適解が部分問題の最適解を含む。古典的問題：活動選択問題、分数ナップサック問題、ハフマン符号化、最小全域木など。貪欲アルゴリズムは簡潔で効率的ですが、正確性を証明する必要があります。'
    },
    tags: ['贪心算法', '局部最优', '全局最优'],
    difficulty: 'medium'
  },
  {
    id: 'algorithms-10',
    category: 'technical',
    subcategory: 'algorithms',
    question: {
      zh: '什么是哈希表？哈希冲突如何解决？',
      ja: 'ハッシュテーブルとは何ですか？ハッシュ衝突をどのように解決しますか？'
    },
    answer: {
      zh: '哈希表是根据键值直接进行访问的数据结构，通过哈希函数将键映射到数组索引。优点：平均情况下插入、删除、查找都是O(1)时间复杂度。哈希冲突是不同的键映射到同一个索引位置。解决方法：1）链地址法（拉链法），在冲突位置维护一个链表；2）开放地址法，线性探测、二次探测、双重哈希等；3）再哈希法，使用多个哈希函数。负载因子是已存储元素数量与哈希表大小的比值，过高会增加冲突概率。好的哈希函数应该：分布均匀、计算简单、雪崩效应（输入微小变化导致输出大幅变化）。',
      ja: 'ハッシュテーブルは、キー値に基づいて直接アクセスするデータ構造で、ハッシュ関数を通じてキーを配列インデックスにマッピングします。利点：平均的な場合、挿入、削除、検索がすべてO(1)時間計算量。ハッシュ衝突は、異なるキーが同じインデックス位置にマッピングされることです。解決方法：1）チェイン法（連鎖法）、衝突位置でリンクリストを維持；2）オープンアドレス法、線形探査、二次探査、二重ハッシュなど；3）再ハッシュ法、複数のハッシュ関数を使用。負荷率は、保存された要素数とハッシュテーブルサイズの比率で、高すぎると衝突確率が増加します。良いハッシュ関数の条件：分布が均等、計算が簡単、雪崩効果（入力の微小変化が出力の大幅変化を引き起こす）。'
    },
    tags: ['哈希表', '哈希冲突', '链地址法', '开放地址法'],
    difficulty: 'medium'
  }
] 