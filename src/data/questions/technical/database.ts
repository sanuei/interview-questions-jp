import { Question } from '@/types'

export const databaseQuestions: Question[] = [
  {
    id: 'database-1',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: 'SQL和NoSQL数据库的区别是什么？各自适用于什么场景？',
      ja: 'SQLとNoSQLデータベースの違いは何ですか？それぞれどのような場面に適していますか？'
    },
    answer: {
      zh: 'SQL数据库是关系型数据库，数据结构固定，支持ACID事务，适合需要强一致性的场景，比如银行系统、电商订单；NoSQL数据库是非关系型的，数据结构灵活，扩展性好，适合大数据、高并发的场景，比如社交网络、日志分析。SQL数据库像Excel表格，行列结构清晰；NoSQL数据库像文档库，可以存储各种格式的数据。选择的时候，如果业务逻辑复杂、需要事务支持，用SQL；如果数据量大、结构变化频繁，用NoSQL。',
      ja: 'SQLデータベースはリレーショナルデータベースで、データ構造が固定されており、ACID取引をサポートし、強い一貫性が必要な場面に適しています。例えば、銀行システム、ECサイトの注文など。NoSQLデータベースは非リレーショナルで、データ構造が柔軟で、拡張性が良く、ビッグデータ、高並行性の場面に適しています。例えば、ソーシャルネットワーク、ログ解析など。SQLデータベースはExcel表のように行列構造が明確で、NoSQLデータベースは文書庫のように様々な形式のデータを保存できます。選択する際は、ビジネスロジックが複雑で取引サポートが必要な場合はSQL、データ量が大きく構造変化が頻繁な場合はNoSQLを使います。'
    },
    tags: ['SQL', 'NoSQL', '数据库选型'],
    difficulty: 'medium'
  },
  {
    id: 'database-2',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: '什么是数据库事务？ACID特性是什么？',
      ja: 'データベーストランザクションとは何ですか？ACID特性とは何ですか？'
    },
    answer: {
      zh: '数据库事务就是一组操作，要么全部成功，要么全部失败，不能只做一半。ACID是事务的四个特性：A是原子性，事务不可分割，要么全做要么全不做；C是一致性，事务前后数据库状态要保持一致；I是隔离性，多个事务同时进行时互不干扰；D是持久性，事务提交后数据永久保存。举个例子，银行转账：从A账户扣钱，给B账户加钱，这两个操作必须同时成功或同时失败，不能只扣了A的钱而B没收到，这就是原子性。',
      ja: 'データベーストランザクションは一連の操作で、全て成功するか全て失敗するかのどちらかで、半分だけ実行することはできません。ACIDは取引の4つの特性です：Aは原子性で、取引は分割不可能で、全て実行するか全て実行しないかのどちらか；Cは一貫性で、取引前後でデータベースの状態が一貫している必要があります；Iは隔離性で、複数の取引が同時に進行する際に互いに干渉しません；Dは持続性で、取引がコミットされた後、データは永続的に保存されます。例えば、銀行振込：Aアカウントからお金を引き出し、Bアカウントにお金を追加する、この2つの操作は同時に成功するか同時に失敗する必要があり、Aのお金だけ引き出されてBが受け取れないということはできません。これが原子性です。'
    },
    tags: ['事务', 'ACID', '数据一致性'],
    difficulty: 'medium'
  },
  {
    id: 'database-3',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: '什么是数据库索引？如何优化查询性能？',
      ja: 'データベースインデックスとは何ですか？クエリパフォーマンスをどのように最適化しますか？'
    },
    answer: {
      zh: '数据库索引就像书的目录，可以快速找到数据位置。没有索引的话，数据库要扫描整个表；有了索引，可以直接定位到数据。索引通常用B+树结构，查询时间从O(n)降低到O(log n)。优化查询性能的方法有：1）为经常查询的字段建索引；2）避免SELECT *，只查询需要的字段；3）使用LIMIT限制返回结果；4）优化WHERE条件，避免函数计算；5）合理使用JOIN，避免笛卡尔积；6）定期分析查询执行计划。但是索引也有成本，会占用存储空间，影响插入更新速度。',
      ja: 'データベースインデックスは本の目次のようなもので、データの位置を素早く見つけることができます。インデックスがないと、データベースは表全体をスキャンする必要がありますが、インデックスがあれば直接データを特定できます。インデックスは通常B+木構造を使用し、クエリ時間をO(n)からO(log n)に削減します。クエリパフォーマンスを最適化する方法は：1）頻繁にクエリするフィールドにインデックスを作成；2）SELECT *を避け、必要なフィールドのみクエリ；3）LIMITを使用して返される結果を制限；4）WHERE条件を最適化し、関数計算を避ける；5）JOINを合理的に使用し、デカルト積を避ける；6）定期的にクエリ実行プランを分析。ただし、インデックスにもコストがあり、ストレージ容量を占有し、挿入更新速度に影響します。'
    },
    tags: ['索引', '查询优化', '性能调优'],
    difficulty: 'medium'
  },
  {
    id: 'database-4',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: '什么是数据库连接池？为什么需要连接池？',
      ja: 'データベースコネクションプールとは何ですか？なぜコネクションプールが必要ですか？'
    },
    answer: {
      zh: '数据库连接池就是预先创建一定数量的数据库连接，放在池子里供应用程序使用。需要连接池的原因是：创建数据库连接很耗时，每次查询都新建连接会很慢；数据库能处理的连接数有限，太多连接会导致数据库崩溃；连接池可以复用连接，提高性能。连接池的工作流程：应用程序需要数据库连接时，从池子里取一个；用完后不关闭连接，而是还回池子；池子会维护最小和最大连接数，根据负载动态调整。常见的连接池有HikariCP、C3P0、Druid等。',
      ja: 'データベースコネクションプールは、予め一定数のデータベース接続を作成し、プールに置いてアプリケーションが使用できるようにすることです。コネクションプールが必要な理由は：データベース接続の作成は時間がかかり、毎回クエリで新しい接続を作成すると遅くなります；データベースが処理できる接続数には限りがあり、接続が多すぎるとデータベースがクラッシュします；コネクションプールは接続を再利用でき、パフォーマンスを向上させます。コネクションプールの動作フロー：アプリケーションがデータベース接続を必要とする時、プールから一つ取得；使用後は接続を閉じずにプールに戻す；プールは最小・最大接続数を維持し、負荷に応じて動的に調整します。一般的なコネクションプールにはHikariCP、C3P0、Druidなどがあります。'
    },
    tags: ['连接池', '数据库连接', '性能优化'],
    difficulty: 'medium'
  },
  {
    id: 'database-5',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: '什么是数据库分库分表？什么时候需要分库分表？',
      ja: 'データベースのシャーディングとは何ですか？いつシャーディングが必要ですか？'
    },
    answer: {
      zh: '分库分表是把一个大数据库拆分成多个小数据库，或者把一个大表拆分成多个小表。分库是垂直拆分，按业务模块分；分表是水平拆分，按数据量分。什么时候需要分库分表：数据量超过单表承受能力（通常几百万到千万级别）；并发量太高，单库扛不住；查询性能下降明显。分库分表的好处是分散压力，提高性能；缺点是增加了复杂度，跨库查询困难，事务处理复杂。分表策略有：按时间分（比如按月分表）、按ID范围分、按hash值分等。',
      ja: 'データベースのシャーディングは、大きなデータベースを複数の小さなデータベースに分割したり、大きなテーブルを複数の小さなテーブルに分割することです。データベース分割は垂直分割で、ビジネスモジュールごとに分けます；テーブル分割は水平分割で、データ量に応じて分けます。いつシャーディングが必要か：データ量が単一テーブルの処理能力を超える場合（通常数百万から千万レベル）；並行性が高すぎて単一データベースで対応できない場合；クエリパフォーマンスが明らかに低下した場合。シャーディングの利点は圧力を分散し、パフォーマンスを向上させること；欠点は複雑度が増し、クロスデータベースクエリが困難で、トランザクション処理が複雑になることです。テーブル分割戦略には：時間による分割（月ごとなど）、ID範囲による分割、ハッシュ値による分割などがあります。'
    },
    tags: ['分库分表', '数据库架构', '扩展性'],
    difficulty: 'hard'
  },
  {
    id: 'database-6',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: '什么是数据库锁？乐观锁和悲观锁的区别是什么？',
      ja: 'データベースロックとは何ですか？楽観的ロックと悲観的ロックの違いは何ですか？'
    },
    answer: {
      zh: '数据库锁是为了解决并发访问时的数据一致性问题。悲观锁认为冲突会经常发生，所以每次访问数据前都先加锁，别人就不能修改了，用完再解锁；乐观锁认为冲突很少发生，所以不加锁，但在更新时检查数据是否被别人修改过，如果被修改就重试。悲观锁的例子：SELECT FOR UPDATE，会锁定查询的行；乐观锁的例子：使用版本号，更新时检查版本号是否一致。悲观锁适合写多读少的场景，乐观锁适合读多写少的场景。悲观锁性能较差但数据安全，乐观锁性能好但可能需要重试。',
      ja: 'データベースロックは、並行アクセス時のデータ一貫性問題を解決するためのものです。悲観的ロックは競合が頻繁に発生すると考え、データにアクセスする前に毎回ロックをかけ、他の人が変更できないようにし、使用後にロックを解除します；楽観的ロックは競合が稀に発生すると考え、ロックをかけませんが、更新時にデータが他の人によって変更されたかをチェックし、変更されていれば再試行します。悲観的ロックの例：SELECT FOR UPDATE、クエリした行をロックします；楽観的ロックの例：バージョン番号を使用し、更新時にバージョン番号が一致するかチェックします。悲観的ロックは書き込みが多く読み取りが少ない場面に適し、楽観的ロックは読み取りが多く書き込みが少ない場面に適しています。悲観的ロックはパフォーマンスが劣るがデータが安全で、楽観的ロックはパフォーマンスが良いが再試行が必要な場合があります。'
    },
    tags: ['数据库锁', '并发控制', '乐观锁', '悲观锁'],
    difficulty: 'medium'
  },
  {
    id: 'database-7',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: '什么是数据库备份和恢复？有哪些备份策略？',
      ja: 'データベースのバックアップとリカバリとは何ですか？どのようなバックアップ戦略がありますか？'
    },
    answer: {
      zh: '数据库备份就是把数据复制保存起来，防止数据丢失；恢复就是从备份中还原数据。备份策略有几种：全量备份，备份整个数据库，恢复快但占用空间大；增量备份，只备份上次备份后的变化，节省空间但恢复慢；差异备份，备份上次全量备份后的所有变化，介于两者之间。备份频率要根据业务需求：重要数据每天备份，一般数据每周备份。还要考虑3-2-1原则：至少3个副本，2种不同介质，1个异地存储。恢复时要注意RTO（恢复时间目标）和RPO（恢复点目标）。',
      ja: 'データベースバックアップはデータをコピーして保存し、データ損失を防ぐことです；リカバリはバックアップからデータを復元することです。バックアップ戦略はいくつかあります：フルバックアップは、データベース全体をバックアップし、リカバリは速いがストレージ容量が大きい；増分バックアップは、前回のバックアップ後の変更のみをバックアップし、容量を節約するがリカバリが遅い；差分バックアップは、前回のフルバックアップ後のすべての変更をバックアップし、両者の中間です。バックアップ頻度はビジネスニーズに応じて：重要なデータは毎日バックアップ、一般的なデータは毎週バックアップ。また、3-2-1原則を考慮：少なくとも3つのコピー、2つの異なるメディア、1つの遠隔地保存。リカバリ時はRTO（リカバリ時間目標）とRPO（リカバリポイント目標）に注意が必要です。'
    },
    tags: ['数据备份', '数据恢复', '备份策略'],
    difficulty: 'medium'
  },
  {
    id: 'database-8',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: '什么是数据库主从复制？读写分离是如何实现的？',
      ja: 'データベースマスタースレーブレプリケーションとは何ですか？読み書き分離はどのように実現されますか？'
    },
    answer: {
      zh: '主从复制是把一个数据库的数据实时同步到另一个数据库。主库负责写操作，从库负责读操作，主库的变化会自动同步到从库。读写分离就是写操作去主库，读操作去从库，这样可以分担主库的压力。实现方式：应用程序层面，代码中判断操作类型，读请求发给从库，写请求发给主库；中间件层面，使用MyCat、Sharding-JDBC等工具自动路由。好处是提高性能，减少主库压力；缺点是数据可能有延迟，从库可能还没同步最新数据。要注意主从延迟问题，可以通过监控延迟时间来解决。',
      ja: 'マスタースレーブレプリケーションは、一つのデータベースのデータを別のデータベースにリアルタイムで同期することです。マスターデータベースは書き込み操作を担当し、スレーブデータベースは読み取り操作を担当し、マスターの変更は自動的にスレーブに同期されます。読み書き分離は、書き込み操作をマスターに、読み取り操作をスレーブに送ることで、マスターの負荷を分散できます。実装方法：アプリケーション層で、コード内で操作タイプを判断し、読み取りリクエストをスレーブに、書き込みリクエストをマスターに送信；ミドルウェア層で、MyCat、Sharding-JDBCなどのツールを使用して自動ルーティング。利点はパフォーマンス向上、マスターの負荷軽減；欠点はデータに遅延が生じる可能性があり、スレーブがまだ最新データを同期していない場合があります。マスタースレーブ遅延問題に注意し、遅延時間を監視することで解決できます。'
    },
    tags: ['主从复制', '读写分离', '数据同步'],
    difficulty: 'medium'
  },
  {
    id: 'database-9',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: '什么是ORM？使用ORM有什么优缺点？',
      ja: 'ORMとは何ですか？ORMを使用する利点と欠点は何ですか？'
    },
    answer: {
      zh: 'ORM是对象关系映射，把数据库的表映射成程序中的对象，这样就可以用面向对象的方式操作数据库。比如Hibernate、MyBatis、JPA等都是ORM框架。优点：开发效率高，不用写SQL语句；代码可读性好，面向对象更直观；数据库无关性，换数据库不用改代码；自动处理连接、事务等。缺点：性能可能不如手写SQL；复杂查询不好处理；学习成本高；调试困难，出错时不知道生成了什么SQL。选择时要根据项目需求：简单的CRUD操作用ORM效率高，复杂的查询和性能要求高的场景建议手写SQL。',
      ja: 'ORMはオブジェクトリレーショナルマッピングで、データベースのテーブルをプログラム内のオブジェクトにマッピングし、オブジェクト指向の方式でデータベースを操作できるようにします。例えば、Hibernate、MyBatis、JPAなどがORMフレームワークです。利点：開発効率が高く、SQLステートメントを書く必要がない；コードの可読性が良く、オブジェクト指向がより直感的；データベース非依存性、データベースを変更してもコードを変更する必要がない；接続、トランザクションなどを自動処理。欠点：パフォーマンスが手書きSQLに劣る可能性がある；複雑なクエリの処理が困難；学習コストが高い；デバッグが困難で、エラー時にどのようなSQLが生成されたかわからない。選択時はプロジェクトのニーズに応じて：シンプルなCRUD操作にはORMが効率的、複雑なクエリやパフォーマンス要求が高い場面では手書きSQLを推奨します。'
    },
    tags: ['ORM', '对象关系映射', 'Hibernate', 'MyBatis'],
    difficulty: 'medium'
  },
  {
    id: 'database-10',
    category: 'technical',
    subcategory: 'database',
    question: {
      zh: '什么是数据库规范化？第一、二、三范式是什么？',
      ja: 'データベース正規化とは何ですか？第一、第二、第三正規形とは何ですか？'
    },
    answer: {
      zh: '数据库规范化是为了减少数据冗余和提高数据完整性而设计表结构的过程。第一范式（1NF）：每个字段都是原子性的，不可再分，比如地址不能放在一个字段里，要分成省、市、区；第二范式（2NF）：在1NF基础上，非主键字段完全依赖于主键，不能只依赖主键的一部分；第三范式（3NF）：在2NF基础上，非主键字段不能依赖于其他非主键字段。规范化的好处是减少数据冗余，避免更新异常；缺点是可能需要更多的表连接，影响查询性能。实际应用中，有时会适当反规范化来提高性能。',
      ja: 'データベース正規化は、データの冗長性を減らし、データの整合性を向上させるためにテーブル構造を設計するプロセスです。第一正規形（1NF）：各フィールドが原子性を持ち、これ以上分割できない。例えば、住所を一つのフィールドに入れず、都道府県、市、区に分ける；第二正規形（2NF）：1NFに基づき、非主キーフィールドが主キーに完全に依存し、主キーの一部のみに依存してはいけない；第三正規形（3NF）：2NFに基づき、非主キーフィールドが他の非主キーフィールドに依存してはいけない。正規化の利点はデータの冗長性を減らし、更新異常を避けること；欠点は、より多くのテーブル結合が必要になり、クエリパフォーマンスに影響する可能性があります。実際の応用では、パフォーマンスを向上させるために適度に非正規化することもあります。'
    },
    tags: ['数据库设计', '范式', '规范化'],
    difficulty: 'medium'
  }
] 